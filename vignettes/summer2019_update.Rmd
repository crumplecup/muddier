---
title: 'summer2019_update'
author: 'Erik Rose'
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{summer2019_update}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


  ```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Summer Update

First I describe the output for the Miller/Burnett model, and how I make use of it in this research.  Second, I describe the process of geolocating Knowles Creek and matching Lancaster transect survey data to analogous positions in the M/B output, and how we use Lancaster sediment deposit data to weight delivery probabilities from the M/B model.  The third section decribes estimating the residence times of deposits by correcting for inherited charcoal age.  The fourth section describes our initial attempts at estimating debris flow deposit flux rates.

## Miller/Burnett Model Output

The Miller/Burnett model uses a 10 meter resolution DEM to estimate debris flow delivery probabilities along stream channels in the Siuslaw basin.  The two primary outputs of the model are a spatial points shapefile representing the channel as a linked node network, and a raster showing expected source intensities at the same resolution as the input DEM.  This research does not make use of the raster of source intensities, rather the primary interest is in the delivery probabilities associated with nodes in the linked-node network representation of the channel.

The Miller/Burnett model uses the input DEM to predict the flow of water across the landscape and estimate stream channel position and extent.  While water can flow from a pixel in any of eight directions depending on the slope and curvature of the pixel, the model defines channels as directional flow across a path of contiguous pixel corners.  Each node in the stream network has a parent node tracing back to the point of initiation, and a child node leading to eventual output from the watershed.

Debris flows have a probability of occurring on each pixel of the landscape, and the model then estimates the aggregate probability of each debris flow reaching the channel, traversing along the channel and depositing in-stream.  The delivery probability of a node represents the cumulative probability of receiving debris flow delivery from all sources in the landscape.  Given that the input DEM was 10m in resolution, a channel node where neighboring nodes are connected along pixel edges represents the 10m of channel nearest to the node position, 5m up- and downstream.  If the channel path crosses a pixel from corner to corner (not across an edge), then the segment length is closer to 14 meters.  Depending upon the combination of neighboring connection lengths, nodes represent channel lengths varying in size from 10-14m, 5-7m up- and downstream of the node position.

The `muddier` package contains functions and data associated with this research project.  The data object `knowles` is the subset of nodes for Knowles Creek.

```{r}
library(muddier)
library(sp)

# the linked-node network for knowles creek is 'knowles'
plot(knowles, pch = 20, col = 'slateblue', xlab = 'knowles creek')

# nodes consist of contiguous pixel corners
plot(knowles[250:265,], pch = 20, col = 'slateblue', xlab = 'zoomed in on nodes')

```

## Georeferencing Knowles Creek

When field researchers record a GPS position of a tributary junction in the Lancaster survey data, the corresponding node on the linked-node network may diverge significantly in location.  First, the model coerces channel position to corner points along a raster matching the input DEM in resolution.  Second, the model applies a smoothing algorithm to avoid jagged or sawtoothed interpretations of smooth channnels traveling at angles to the raster pixel edges.  The additive results of both processes can result in significant spatial divergence in position from the actual location of a given landmark.

The distance between landmarks along the linked-node network can vary from the hipchain distances recorded in the Lancaster survey data due to the same two processes, namely coercion to a 10m raster and channel smoothing.  Hipchain distances relative to node network distances may either be stretched or shrunken.  

During a 2006 survey, Lancaster recorded the GPS coordinates of a number of tributary junctions along Knowles and assigned them id numbers.  Although the majority of the tributary junctions recorded are downstream of the portion of the channel later surveyed by transect, the transect surveyors noted the presence of four tributary junctions recorded by Lancaster in 2006, which I was also able to locate by valley topography in LiDAR imagery and find a clear analogue in the linked-node network representation.

Transect survey field notes also referenced three tributary junctions further upstream, naming two of the tributaries as Heron and Boomer creeks, and noted the third to be intersecting the right bank of Knowles at hipchain 1448.  The tributary junctions were identifiable by valley topography evident in LiDAR imagery of the area, and had clear analogues in the linked-node network.  Lancaster also recorded GPS positions at hipchains 793 and 2907 in 2006.

The node shapefile from the Miller/Burnett output includes a variable called `ToMouth_km` which represents the distance to the channel outlet in kilometers for a given channel node.  The difference in `ToMouth_km` values between nodes, whether it is greater or smaller than the hipchain distance recorded in the field survey between the same landmarks, determines the degree to which the hipchain distances have expanded or shrunken by coercion to the linked-node network.  To estimate the position of a transect on the node network given the hipchain distance from the Lancaster survey, I first multiply the hipchain length of the transect distance by the ratio between the outlet and hipchain length, resulting in an estimated outlet distance for the transect.  Then I find the nearest node to the estimated transect position and assign the transect to the node.

The `muddier` package includes the resulting data object called `landmarks`.  The `x` and `y` variables record the spatial position of the landmark node, `hip` records the hipchain distance upstream of the tributary junction for K-38, corrected for elevation, `nodeid` records the id of the corresponding node in the linked-node network for the landmark, `kmtout` is renamed from `ToMouth_km` and stands for 'kilometers to outlet', and `outhip` is the ratio of the difference in outlet distance and hipchain distance between the current and preceding node in the table. For the most upstream portion of the transect survey, lacking a landmark upstream of the survey site, I make the compromise of assuming the outlet to hipchain ratio is identical to the ratio for the nearest known segment of the survey area.  Generally, hipchain distances are longer than outlet distances, both because the field researcher may cross banks in the process of securing the hipchain, elongating the distance traveled by taking a more sinuous travel path, and because the node-network representation is algorithmically smoothed, which shortens the path distance by reducing jaggedness in the path.

```{r}
landmarks
```


Survey data at transects include valley sediment wedge area and contributing area.  For nodes lying between transects, I estimate sediment wedge area and contributing area by linear interpolation.  The Lancaster survey covers a channel segment consisting of 327 nodes, which I have saved into the `muddier` package as the object `transects`.


```{r}
plot(knowles, pch = 20, col = 'slateblue')
points(transects, pch = 20, col = 'forestgreen')
points(landmarks[ , 1:2], pch = 20, col = 'coral3')
legend('bottomleft', legend = c('knowles creek', 'transects', 'landmarks'),
       fill = c('slateblue', 'forestgreen', 'coral3'))

```

## Debris Flow Residence Times

The Lancaster dataset includes 370 radiocarbon-dated charcoal samples from stream bank deposits in Knowles, Bear, Cedar and Golden Ridge creeks.  The sample ages can characterize the residence times of debris flows and fluvial deposits in stream, as the deposit cannot be older than the youngest piece of charcoal in the deposit.  The period of time a piece of charcoal spends before becoming entrained in a stream deposit is the inherited age, and the sample age of the charcoal is the sum of the residence time of the deposit and the inherited age of the charcoal.

The field researchers collected multiple samples at deposit sites for debris flows, fluvial fines and fluvial gravels to assess the distribution of inherited ages in entrained charcoal.  The sample ages come back from the lab as age distribution curves discretized to 5-year intervals, showing the probability that the sample age falls within a given 5-year range, comprising a PMF.  At each site with multiple samples, I subtracted the PMF of the youngest sample from the PMF of each sample at that site via convolution, including the youngest sample itself.  Then I summed together the convolved PMFs by facies and renormalized to produce an inherited age distribution for each facies.  I characterized the uncertainty around each inherited age distribution by bootstrapping.

The `muddier` vignette describes the functions and data objects used to estimate inherited age distributions and residence times, which is available at https://crumplecup.github.io/muddier/articles/muddier.html.

```{r}
# plot inherited age CDF for debris flows
library(magrittr)
index <- char_pmfs %>% rownames %>% as.numeric %>% sort
plot(index, df_cdf, lwd = 2, type = 'l', xlim = c(0, 11000),
     xlab = 'inherited age (debris flows)',
     ylab = 'proportion <= age')  # empiric cdf
lines(index, df_cdfs_cis[1,], lty = 2, col = 'coral3', lwd = 2)  # lower 97.5% CI
lines(index, df_cdfs_cis[3,], lty = 2, col = 'coral3', lwd = 2)  # upper 97.5% CI
lines(index, unlist(df_ph_cdf), lty = 2, col = 'slateblue', lwd = 2)  # phase-type fit
legend('bottomright', legend = c('empiric', '95% CIs', 'phase-type fit'),
       fill = c('black', 'coral3', 'slateblue'))
```


I used the KPC Toolbox in Matlab to fit the empirical distribution of inherited age to a number of continuous distributions, namely the exponential, gamma, Weibull and phase-type distributions.  We used the Kuiper statistic and Kolomogorov-Smirnov test to reject the exponential, gamma and Weibull distributions.  Prony's method provided the distrubtion with the best goodness of fit statistic for debris flows, while the Weibull distribution provided the best fit for fluvial fines and fluvial gravels.

Using the fit distributions for inherited age for each facies, I then estimate the residence time of deposits with only one sample by subtracting the inherited age distribution from the sample age PMF using convolution.  In the `charcoal` dataset, where samples are arranged from youngest to oldest mean estimed sample age, we can compare the difference between esimated mean sample age and estimated mean residence time to illustrate the general size of the inherited age correction.

```{r}
# expected mean residence time of corrected pmfs
cor_mns <- vector(ncol(cor_pmfs), mode = 'numeric')
for (i in 1:ncol(cor_pmfs))  {
  cor_mns[i] <- weighted.mean(index, cor_pmfs[,i])
}

# difference in uncorrected and corrected mean residence times
mn_difs <- charcoal$mn - cor_mns

# plot residence time differences colored by facies
df_difs <- vector(length(mn_difs), mode = 'numeric')
ff_difs <- vector(length(mn_difs), mode = 'numeric')
fg_difs <- vector(length(mn_difs), mode = 'numeric')

df_difs[charcoal$facies == 'DF'] <- mn_difs[charcoal$facies == 'DF']
df_difs[charcoal$facies != 'DF'] <- NA
ff_difs[charcoal$facies == 'FF'] <- mn_difs[charcoal$facies == 'FF']
ff_difs[charcoal$facies != 'FF'] <- NA
fg_difs[charcoal$facies == 'FG'] <- mn_difs[charcoal$facies == 'FG']
fg_difs[charcoal$facies != 'FG'] <- NA

plot(fg_difs, pch = 20, col = 'coral3',
     xlab = 'sample id', ylab = 'mean inherited age')
points(ff_difs, pch = 20, col = 'slateblue')
points(df_difs, pch = 20, col = 'forestgreen')
legend('topleft', legend = c('debris flows', 'fluvial fines', 'fluvial gravels'),
       fill = c('forestgreen', 'slateblue', 'coral3'))
```

In the same manner as for inherited age, I used the KPC Toolbox in Matlab to fit the empirical distribution of residence times for each facies to a number of continuous distributions, using the Kuiper statistic and K-S test to determine goodness of fit.

## Examining Delivery Probabilities

During the transect survey, the field researchers selected transect positions that captured inflections in the valley contour.  By recording the depth of sediment across the transect, the researcher can estimate the volume of sediment in a valley area by linear interpolation due to careful selection of transect position to represent the valley contour.

In a similar manner to how Miller & Burnett used landslide runout track surveys to calibrate a topological index to an empiric record of debris flows, we can use the transect record of valley sediment deposition to calibrate predicted delivery probabilities in the Miller/Burnett model.  However, comparison of cross-sectional area at transects to Miller/Burnett delivery probabilities shows poor correlation between delivery probabilties and sediment deposition along the channel. Examining the relation between delivery probabilities and slope, contributing area, top valley width, and area-slope product showed similarly poor correlation, with only slope showing mildly positive correlation.

```{r}
plot(transects$DebrisFlow, transects$area,
     col = rgb(red=1, green=0, blue=.2, alpha=.5), pch=20,
     ylab='Cross-sectional Area (m2)', xlab='Delivery Probability' )
abline(lm(transects$area ~ transects$DebrisFlow),col='gray')

plot(transects$DebrisFlow, transects$GRADIENT,
     col = rgb(red=0, green=.2, blue=1, alpha=.5), pch=20,
     ylab='Slope', xlab='Delivery Probability' )
abline(lm(transects$GRADIENT ~ transects$DebrisFlow),col='gray')

plot(transects$DebrisFlow, transects$contr,
     col = rgb(red=.5, green=1, blue=.7, alpha=.5), pch=20,
     ylab='Contributing Area (km2)',xlab='Delivery Probability' )
abline(lm(transects$contr ~ transects$DebrisFlow),col='gray')

area_slope <- transects$GRADIENT * transects$contr
plot(transects$DebrisFlow, area_slope,
     col = rgb(red=.5, green=0, blue=1, alpha=.5), pch=20,
     ylab='Contr Area * Slope',xlab='Delivery Probability' )
abline(lm(area_slope ~ transects$DebrisFlow),col='gray')

plot(transects$DebrisFlow, transects$top,
     col = rgb(red=.5, green=0, blue=.7, alpha=.5), pch=20,
     ylab='Top Valley Width (m)',xlab='Delivery Probability' )
abline(lm(transects$top ~ transects$DebrisFlow),col='gray')

```


## Weighting Delivery Probabilities

Let $P$ represent delivery probabilities, and let $F_P (P_0)$ be the CDF of delivery probabilities.  Let $V$ represent depositional volume, and let $F_V (P_0)$ be the CDF of volume with respect to $P$.  The volume weighting function $wt_V$ over an interval $P_i$ to $P_{i + 1}$ along $P$ is:

$$ wt_V (P_i, P_{i+1}) = \frac{F_V (P_{i+1}) - F_V (P_i)}{F_P (P_{i+1}) - F_P (P_i)} $$



```{r}

# weighting function for delivery probs

# delivery prob index
p_index <- sort(transects$dfprob)

# cdf of delivery probs
p_cdf <- to_cdf(p_index/sum(p_index))

# change in delivery prob cdf per change in index
delta_p <- vector(length(p_index), mode = 'numeric')
for (i in 2:length(delta_p))  {
  delta_p[i] <- p_cdf[i] - p_cdf[i-1]
}

# cdf of volume by prob index
v_cdf <- vector(length(p_index), mode = 'numeric')
for (i in 2:length(v_cdf))  {
  v_cdf[i] <- sum(transects$area[transects$dfprob <= p_index[i]]) /
    sum(transects$area)
}

# change in volume cdf per change in index
delta_v <- vector(length(p_index), mode = 'numeric')
for (i in 2:length(delta_v))  {
  delta_v[i] <- v_cdf[i] - v_cdf[i-1]
}

# change in volume cdf per change in del prob cdf
p_wt <- delta_v / delta_p
p_wt_cdf <- to_cdf(p_wt[-1] / sum(p_wt[-1]))

plot(p_index, p_wt, pch = 20, col = rgb(red=.5, green=0, blue=.7, alpha=.5),
     xlab = 'delivery probability', ylab = 'F(V)/F(P)')
abline(lm(p_wt ~ p_index), col = 'gray')

plot(p_index[-1], p_wt_cdf, type = 'l', lwd = 2, col = 'slateblue',
     xlab = 'delivery probability', ylab = 'cdf')
lines(p_index, v_cdf, lwd = 2, col = 'coral3')
lines(p_index, p_cdf, lwd = 2, col = 'forestgreen')
legend('bottomright', 
       legend = c('delivery prob F(P)', 'volume F(V)', 'F(V)/F(P)'),
       fill = c('forestgreen', 'coral3', 'slateblue'))

```

### Weighting by Area-Slope Relation

We can fit the area-slope relation to a power law where slope $S$ relates to contributing area $A$ by the function:

$$ S = k_sA^{-\theta}  $$

We can relate logged slope to logged contributing area using a linear model, so that:

$$  log(S) = log(k_sA^{-\theta})  $$
$$  log(S) = log(k_s) - \theta log(A)  $$
We can estimate $\theta$ as the slope of a linear model with intercept $log(k_s)$.  Based upon the estimated $\theta$ we can then calculate an individual $k_s$ for each channel node.


```{r}


# find ks values in S = ks(A^theta)
lslope <- transects$GRADIENT %>% log  # logged slope
lcontr <- transects$contr %>% log # logged contr area

as_mod <- lm(lslope ~ lcontr)  # fit AS to power law
as_theta <- as_mod$coefficients[2]  # pull theta value

plot(lcontr, lslope, pch = 20, col = rgb(red=.5, green=0, blue=.7, alpha=.5),
     xlab = 'log(contributing area)', ylab = 'log(slope)')
abline(as_mod, lwd = 2, col = 'goldenrod')
text(1,-2, 'R2 = 0.78')

# estimate individual ks values using pulled theta
log_ks <- lslope - as_theta * lcontr
ks <- exp(log_ks)
transects$p_ks <- transects$dfprob / ks

plot(p_index, ks, pch = 20, col = rgb(red=.5, green=0, blue=.7, alpha=.5),
     xlab = 'delivery probability')

```

Using the ratio of $P/k_s$, let $F_{P/k_s}(P_0)$ be the CDF of $P/k_s$ with respect to $P$.  We can then compare change in the CDF of $P/k_s$ to change in the CDF of $P$.  The $P/k_s$ weighting function $wt_{P/k_s}$ over an interval $P_i$ to $P_{i + 1}$ along $P$ is:

$$ wt_{P/k_s} (P_i, P_{i+1}) = \frac{F_{P/k_s} (P_{i+1}) - F_{P/k_s} (P_i)}{F_P (P_{i+1}) - F_P (P_i)} $$

```{r}

plot(p_index, transects$p_ks, pch = 20, 
     col = rgb(red=.5, green=0, blue=.7, alpha=.5),
     xlab = 'delivery probability', ylab = 'P/ks')
abline(lm(transects$p_ks ~ p_index), col = 'gray')

# cdf of ks / pdel ratio over pdel
p_ks_cdf <- vector(length(p_index), mode = 'numeric')
for (i in 2:length(p_ks_cdf))  {
  p_ks_cdf[i] <- sum(transects$p_ks[transects$dfprob <= p_index[i]]) /
    sum(transects$p_ks)
}

# change in p_ks cdf per change in index
delta_p_ks <- vector(length(p_index), mode = 'numeric')
for (i in 2:length(delta_p_ks))  {
  delta_p_ks[i] <- p_ks_cdf[i] - p_ks_cdf[i-1]
}

# change in volume cdf per change in del prob cdf
p_ks_wt <- delta_p_ks / delta_p
p_ks_wt_cdf <- to_cdf(p_ks_wt[-1] / sum(p_ks_wt[-1]))


plot(p_index[-1], p_ks_wt_cdf, type = 'l', lwd = 2, col = 'slateblue',
     xlab = 'delivery probability', ylab = 'cdf')
lines(p_index, p_ks_cdf, lwd = 2, col = 'coral3')
lines(p_index, p_cdf, lwd = 2, col = 'forestgreen')
legend('bottomright', 
       legend = c('delivery prob F(P)', 'F(P/ks)', 'F(P/ks)/F(P)'),
       fill = c('forestgreen', 'coral3', 'slateblue'))
```

We can follow the same procedure using top valley width, with distance $D$ representing valley width, let $F_D (P_0)$ be the CDF of $D$ with respect to $P$.  The valley width weighting function $wt_D$ over an interval $P_i$ to $P_{i + 1}$ along $P$ is:

$$ wt_D (P_i, P_{i+1}) = \frac{F_D (P_{i+1}) - F_D (P_i)}{F_P (P_{i+1}) - F_P (P_i)} $$

```{r}

# cdf of top width by prob index
top_cdf <- vector(length(p_index), mode = 'numeric')
for (i in 2:length(top_cdf))  {
  top_cdf[i] <- sum(transects$top[transects$dfprob <= p_index[i]]) /
    sum(transects$top)
}

# change in top width cdf per change in index
delta_top <- vector(length(p_index), mode = 'numeric')
for (i in 2:length(delta_top))  {
  delta_top[i] <- top_cdf[i] - top_cdf[i-1]
}

# change in top width cdf per change in del prob cdf
top_wt <- delta_top / delta_p
top_wt_cdf <- to_cdf(top_wt[-1] / sum(top_wt[-1]))

plot(p_index, top_wt, pch = 20, 
     col = rgb(red=.5, green=0, blue=.7, alpha=.5),
     xlab = 'delivery probability', ylab = 'F(D)/F(P)')
abline(lm(top_wt ~ p_index), col = 'gray')

plot(p_index[-1], top_wt_cdf, type = 'l', lwd = 2, col = 'slateblue',
     xlab = 'delivery probability', ylab = 'cdf')
lines(p_index, top_cdf, lwd = 2, col = 'coral3')
lines(p_index, p_cdf, lwd = 2, col = 'forestgreen')
legend('bottomright', 
       legend = c('delivery prob F(P)', 'valley width F(D)', 'F(D)/F(P)'),
       fill = c('forestgreen', 'coral3', 'slateblue'))
```












