---
title: 'muddier'
author: 'Erik Rose'
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{muddier}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


  ```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction to `muddier`

The package \code{muddier} is inspired by the field of fluvial geomorphology.  Correcting for the inhertied ages of radiocarbon-dated charcoal in samples of debris-flow deposits in headwater streams concerns a particular application of deriving a PMF from two parent PMFs through convolution.  The functions in \code{muddier} are an attempt to abstract the particulars of the application into a more general set of tools for converting emprical observational data into CDFs, PMFs, and for deriving PMFs from multiple parent PMFs.


## Charcoal Data


The `muddier` package includes data from Lancaster & Casebeer (2007) on charcoal samples taken from bank stratigraphy adjacent to headwater streams in the OCR.  The table `charcoal` contains site data from the field surveys where they collected the charcoal samples.  The table `char_pmfs` is the radiocarbon age distribution associated with each sample.  To load the data, you can use the `data` function, or simply type `library(muddier)`.

```{r}
library(muddier)

# load package data without loading package
# data(charcoal, package = 'muddier')
# data(char_pmfs, package = 'muddier')

# inspect charcoal table
head(charcoal)
```

The `charcoal` dataset has 370 observations listed as rows.  The rownames of the object and the first column of data are the site ids.  At sites where the researchers took multiple samples, the site ids will have letters appended to them (eg. LK-187a, LK-187b, LK-187c).  The `family` column is the site id stripped of any ending letters, so that all observations from the same site share the same family id.  Researchers classified the deposit type of samples as fluvial fines (FF), fluvial gravels (FG) and debris-flow deposits (DF).  The `facies` column indicates the facies type using the two-letter classification codes (FF, FG, DF).  The `mn` column is the mean sample age BP as derived from the pmf in `char_pmfs`, and `rank` is the ordinal rank of each sample from youngest to oldest.

If we examine the dimensions of each dataset, we see that both have 370 observations, but `char_pmfs` has 4,430 columns.  If we plot the values of a row against the values of the columns names, the result is the age distribution pmf of the sample.

```{r}
library(magrittr)

# compare dimensions of objects
dim(charcoal)
dim(char_pmfs)

years <- char_pmfs %>% colnames %>% as.numeric
probs <- char_pmfs[250,] %>% as.numeric

plot(years, probs, xlim=c(1000,1400), main='pmf of ob# 250')
```

To produce these two datasets, I performed several operations on a csv file converted from the Excel file containing the original Lancaster & Casebeer (2007) data.  The file used to perform these operations is stored in the `data-raw` folder on the github reposity for this project.  Compared to the original data, this data has been sorted by mean age, and split into two datasets, one for sample variable data and one for numeric pmf vectors associated with each sample.

Before we begin analyzing the data, I would like to verify that the datasets have been sorted correctly, and that the pmfs all sum to 1.  First I will make sure the rownames of the two datasets match, then I will test that each row of `char_pmfs` sums to 1.  Finally, I want to make sure the calculated means in `charcoal` match the means of the pmfs in `char_pmfs`.  To do this, I use the `testthat` package which employs the function `expect_equal`.  If the two arguments are equal to within a tolerance range, the test passes silently.  If the two arguments are not equal, the test fails with a warning.  Failure causes abortion of vignette construction, so every time you see a test run in code, that means it has passed.  I will explicitly mark unexecuted lines of code with the comment `# not run` at the top of the code snippet.


```{r}
library(testthat)

# load package data
data(charcoal, package = 'muddier')
data(char_pmfs, package = 'muddier')

years <- char_pmfs %>% colnames %>% as.numeric
mns <- apply(char_pmfs, 1, function(a) weighted.mean(years, a))


# test rownames are equal
# test means are equal

test_that('charcoal and char_pmfs match', {
  expect_equal(rownames(charcoal), rownames(char_pmfs))
  expect_equal(as.numeric(charcoal$mn), as.numeric(mns))
})


# test the pmfs sum to 1
sums <- apply(char_pmfs, 1, sum) %>% as.numeric
ones <- rep(1, nrow(char_pmfs))
max(sums-ones)  # examine tolerance

test_that('pmfs in char_pmfs sum to 1', {
  expect_equal(sums, ones, tolerance = 1e-4)
})
```
Note that the pmfs will not sum exactly to one due to rounding error.  First I examine the maximum size of the rounding error with `max(sums-ones)`.  I explictly set `tolerance = 1e-4` to ingore this rounding error.  Having passed the initial round of tests, I am confident the two datasets are correctly ordered and match, and we can proceed to calculate inherited age.


<<<<<<< HEAD
## Subsetting sites
=======
## Subsetting sites by family and facies
>>>>>>> e8abb4c20cf9dd6905965484e2b0b08aa30282b8

`charcoal` is organized as a data.table to enable simple subsetting operations by the user.  The convenient `.N` term for delineating number of observations is convenient for producing summary statistics, when combined with `by` indicated the variable for which to count observations.  The data.table format allows the user to treat column names as variables when inside brackets, so subsetting a data.table using a logical test is as straightforward as `charcoal[facies == 'DF']`.

```{r}
library(data.table)

# subset by facies
df_count <- charcoal[facies == 'DF', .N, by = family]
ff_count <- charcoal[facies == 'FF', .N, by = family]
fg_count <- charcoal[facies == 'FG', .N, by = family]

# family ids of sites with > 3 obs
df_count[N>3]
ff_count[N>3]
fg_count[N>3]

```

## Inherited Age

Inherited age is the age of the charcoal before becoming entrained in bank deposits.  By taking multiple samples of a facies type at a single sampling site, Lancaster & Casebeer (2007) were able to estimate a distribution range around inherited age.

`charcoal` is intentionally sorted by rank so that an index of ranks is equivalent to the index of observations by row.  Furthermore, the rank number of a sample from `charcoal` is equivalent to row number of the pmf for the same sample in `char_pmfs`.  Rather than searching by site_id, I have elected to use rank number, and so the function `rank_list(ftype, dat = charcoal, min_count = 3)` returns the ranks of observations of a given facies type from `dat` above a minimum count `min_count`, with `dat` set to the charcoal data as a default, and minimum count set to 3.


The concluding test in the snippet tells me that the ranks returned by the function `rank_list()` have the same family ids as the subsets in the previous example.


```{r}

df_ranks <- rank_list('DF')
ff_ranks <- rank_list('FF')
fg_ranks <- rank_list('FG')

# inspect output
df_ranks[[1]]

# family ids pulled by rank
df_by_ranks <- charcoal[rank %in% unlist(df_ranks), family] %>% factor %>% levels %>% sort
ff_by_ranks <- charcoal[rank %in% unlist(ff_ranks), family] %>% factor %>% levels %>% sort
fg_by_ranks <- charcoal[rank %in% unlist(fg_ranks), family] %>% factor %>% levels %>% sort

# family ids pulled by count
df_by_count <- df_count[N>3,family] %>% unlist %>% sort
ff_by_count <- ff_count[N>3,family] %>% unlist %>% sort
fg_by_count <- fg_count[N>3,family] %>% unlist %>% sort

test_that('rank list matches family ids', {
  expect_equal(df_by_ranks, df_by_count)
  expect_equal(ff_by_ranks, ff_by_count)
  expect_equal(fg_by_ranks, fg_by_count)
})

```

I can examine the pmfs associated with a rank list using the function `pmf_by_rank(ranks, pmfs = char_pmfs)`.  Because the default argument for `pmfs` is set to `char_pmfs`, this second argument can be ommitted in this instance.  When passed a vector of ranks to the first argument `ranks`, `pmf_by_rank` returns a data.table with pmfs for each rank stored by row, with probabilities stored in columns and year values stored as column names.

When passed a list of rank vectors, as output by `rank_list`, to the first argument `ranks`, `pmf_by_rank` returns a list of data.tables, each containing the pmfs associated with ranks in the rank list, with probabiliites stored in column and year values stored as column names.

To test the functionality of `pmf_by_rank`, I am mostly concerned that I have inadvertently scrambled the pmfs.  I am already highly confident the rows of both datasets match, and the pmfs sum to 1, so now I would like to ensure they are ordered within each family from youngest to oldest.

```{r}
# return pmfs by rank
df_pmfs <- pmf_by_rank(df_ranks)
ff_pmfs <- pmf_by_rank(ff_ranks)
fg_pmfs <- pmf_by_rank(fg_ranks)

df_mns <- lapply(df_pmfs, function(a) lapply(1:nrow(a),
                                             function(b, c) weighted.mean(years, c[b,]), c = a))
ff_mns <- lapply(ff_pmfs, function(a) lapply(1:nrow(a),
                                             function(b, c) weighted.mean(years, c[b,]), c = a))
fg_mns <- lapply(fg_pmfs, function(a) lapply(1:nrow(a),
                                             function(b, c) weighted.mean(years, c[b,]), c = a))

test_that('pmfs are sorted in ascending age', {
  for (i in seq_along(df_mns))  {
    expect_equal(as.numeric(df_mns[[i]]), sort(as.numeric(df_mns[[i]])))
  }
  for (i in seq_along(ff_mns))  {
    expect_equal(as.numeric(ff_mns[[i]]), sort(as.numeric(ff_mns[[i]])))
  }
  for (i in seq_along(fg_mns))  {
    expect_equal(as.numeric(fg_mns[[i]]), sort(as.numeric(fg_mns[[i]])))
  }
})

```

















